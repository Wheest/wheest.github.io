---
layout: post
title:  "Misc MLIR errors: for your convenience"
date:   2022-11-30 19:52:08 +0000
categories: blog
tags: mlir compilers cpp
excerpt_separator: <!--more-->
---

<img src="/assets/pics/2022_mlir_errors.png" width="1024">

The following is a log of some errors I've encountered in MLIR, and how I fixed them.
Solutions to many of these were found through search engines and various forums (e.g., the LLVM forum), however I am centralising errors for my own reference.
I believe that many of these are likely to be common errors for people initially exploring MLIR.
Note that at the time of writing, MLIR is changing quickly, and some of these fixes may no longer be relevant.
In fact, several of my issues below emerged due to such changes.
I may add additional errors here over time.

<!--more-->

#### func

##### custom op 'func' is unknown
```sh
error: custom op 'func' is unknown (tried 'builtin.func' as well)
```
At some point, MLIR made `func` [its own dialect](https://mlir.llvm.org/docs/Dialects/Func/).

Whereas before we would write:

```mlir
func @do_something()
```

We now should write:
```mlir
func.func @do_something()
```

However, this opened up another error for me, see below.

##### Dialect `func' not found

Editing my MLIR code to `func.func` should work in principle, but trying to compile my IR resulted in the error:

```sh
error: Dialect `func' not found for custom op 'func.func'
```

The issue was that the list of my optimizations (e.g., `-convert-linalg-to-loops`, `-lower-affine`, etc) did not include the one required to process the new `func` dialect.
Therefore, I needed to add `-convert-func-to-llvm` (quite near the end of the passes).

#### Misc

```
error: Dialect `scf' not found for custom op 'scf.for'
```

This is the structured control flow dialect, which was being generated by some of my other passes.
However, I wasn't lowering it further.
Here I was missing `--convert-scf-to-cf` for `mlir-opt`.

```sh
error: Dialect `memref' not found for custom op 'memref.load'
```

`memref` needs to be converted to LLVM.
The `--finalize-memref-to-llvm` pass can be used for this.


```
error: LLVM Translation failed for operation: builtin.unrealized_conversion_cast
Error: could not convert to LLVM IR
```

This appeared when I was attempting to execute some code with `mlir-cpu-runner`.
Adding `--reconcile-unrealized-casts` the pass to `mlir-opt` helped.


```
JIT session error: Symbols not found: [ print_memref_2d_f64 ]
Error: Failed to materialize symbols: { (main, { main, _mlir_main, _mlir_matmul, matmul }) }
```

This appeared when I was attempting to execute some code with `mlir-cpu-runner`.
Essentially, I was attempting to use the function `print_memref_2d_f64`, which is a helper function defined in the `mlir_runner_utils`.
But I was not linking that library to `mlir-cpu-runner`.
This was corrected by adding `-shared-libs` with the path to `libmlir_runner_utils.so` to my `mlir-cpu-runner` call.
You can see the issue of how to support printing discussed in [this forum post](https://discourse.llvm.org/t/print-in-mlir/1701/15), however it is a bit out of date.
E.g.:
```sh
mlir-cpu-runner -O3 -e main -entry-point-result=void \
    -shared-libs=$LLVM_ROOT/build/lib/libmlir_runner_utils.so
```
