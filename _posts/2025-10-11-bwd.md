---
layout: post
title: "Show Me Your Code: Binary White Dwarfs"
date: 2025-10-11 12:20:08 +0200
categories: blog
tags: python science physics
excerpt_separator: <!--more-->
---

I've recently been chatting with Melize Ferrus, currently working on her PhD in
astrophysics, looking in the dynamics of black hole mergers.

It's not an area I have much expertise in, but through a series of chats, and
playing around with some of her code (making some fun demos), I thought I'd discuss what I've learned.

<!--more-->

I've asked Melize to write some clarifications and corrections, which will
appear as quotes like this.

The rest of the text is my understanding, and may contain errors. Anything you
see that is wrong is my fault, not Melize's. Everything should be prefixed with
"I reckon".

> This is a quote from Melize Ferrus, PhD candidate in astrophysics.

# The Problem Area

The Python notebooks that Melize had been working with were looking at binary
white dwarf systems. These are pairs of white dwarf stars (which are the cores
of dead stars, around the mass of our sun) orbiting each other.

There are a few reasons why these systems are interesting to study. From what I
gather though, under particular interest is that when these stars get close to
each other, they can produce very small gravitational waves.

It is difficult to detect gravitational waves from such small systems, but the
reason why we care is that they contribute noise, or "background radiation", to
the gravitational wave signals we care about, such as those from black hole mergers.

Therefore, understanding these white dwarf systems helps us to better interpret
the gravitational wave data we receive from detectors like LIGO and Virgo.

# The Code

I saw that Melize's code had two main parts, both of which using "Gibbs
Sampling".
Gibbs sampling is a statistical technique used to generate samples from a
probability distribution.

The two main parts were:

- Drawing samples of what the binary white dwarf systems might look like
  (e.g. their masses, distances, and orbital periods).
- Generating _where_ in the galaxy these systems might be located.

We have modelled what we think the distribution of these systems looks like, and
what this code is doing is drawing samples from this distribution.
The specifics of the distributions are not important for this discussion, and
not something I've taken the time to understand.

# Binary White Dwarf Systems

When we generate a sample of a binary white dwarf system, we are generating:

- The mass of the first white dwarf (in solar masses)
- The mass of the second white dwarf (in solar masses)
- Their orbital separation (in solar radii)
- Their orbital eccentricity (what shape their orbit is)

For example, a sample I generated from Melize's code was:

**Example Binary White Dwarf System**

\[
\begin{aligned}
m*1 &= 1.33\,M*\odot \\
m*2 &= 0.64\,M*\odot \\
e &= 0.38 \\
a &= 7.26 \times 10^5\,R\_\odot
\end{aligned}
\]

To help with my own exploration, I also gave each system a random name, using 2 words from the [EFF Long
Wordlist](https://www.eff.org/dice).

E.g.,

```
overrun-nicotine
stack-thursday
goldmine-undesired
strained-hurried
ecologist-undead
cherisher-degree
supermom-unsigned
rescuer-sternum
zebra-crepe
```

From this code, we can generate as many samples as we want, and our set of
binary white dwarf systems will be distributed according to our model.

# Galactic Coordinates

We expect the white dwarf systems to be distributed around the milky way galaxy,
with a higher density towards the center of the galaxy, and a lower density as
we move away from the center.

The galaxy is modelled as a disk, with a bulge in the center. The model that
Melize uses "cylindrical galactic coordinates", which are:

- \(R\): Galactocentric radial distance: the distance from the center of the
  galaxy.
- `\(Z\)`: the vertical distance above or below the galactic midplane

This is in contrast to the more familiar cartesian coordinates `(x, y, z)`.
However, to convert from galactic coordinates to cartesian coordinates, we also
need the "azimuthal" angle `\(\phi\)`, which is the angle around the center of the
galaxy. This requires an assumption of how the systems are distributed around
the galaxy.
This isn't necessary for Melize's work, but I wanted to visualise the results in
a format I was more familiar with.

Therefore I added a third step to the code, which was to draw a random angle
between `[0, Ï„]`, and then convert from galactic coordinates to cartesian ones.

This plot is interactive, using the `plotly` library, and its `go.Scatter3d`.
You can see it below in the next section.

<div id="binaries_plot" style="width:100%;height:600px;"></div>

# Messing Around

Another thing I was interested in was something musical.

---

Testing replacement: <span id="pronoun"></span> went to the store. Later, <span
class="pronoun"></span> met with friends, and <span class="pronoun"></span> said
goodbye.

<script>
(function() {
  const pronouns = ["she", "he", "they"];
  // randomize once per page load
  const chosen = pronouns[Math.floor(Math.random() * pronouns.length)];
  // replace #pronoun with the random one
  const first = document.getElementById("pronoun");
  if (first) first.textContent = chosen;
  // cycle through for others
  const spans = document.querySelectorAll(".pronoun");
  spans.forEach((el, i) => {
    el.textContent = pronouns[(pronouns.indexOf(chosen) + i + 1) % pronouns.length];
  });
})();
</script>

<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<div id="binaries_plot" style="width:100%;height:600px;"></div>
<script>
fetch('/assets/plotly/2025-10-binaries.json')
  .then(r => r.json())
  .then(fig => Plotly.newPlot('binaries_plot', fig.data, fig.layout, {responsive:true}));
</script>
